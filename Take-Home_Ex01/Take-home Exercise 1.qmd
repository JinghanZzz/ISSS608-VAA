---
title: "Take-home Exercise 1"
author: "ZHANG Jinghan"
date: "September 9,2024"
date-modified: "last-modified"
excute:
  ecal: true
  echo: true
  freeze: true
  warning: false
editor: 
  markdown: 
    wrap: 72
---

```{r}
pacman::p_load(sf, tidyverse, tmap, spNetwork, ggstatsplot)
```

####01 Data. ###1.1 Thai Road Accident Data Read in CSV file containing
road accident data in Thailand (2019-2022). Extract month and day of the
week from the incident datetime, remove rows with missing coordinates,
convert the data into a spatial (sf) object, and transform the
coordinate reference system to UTM Zone 47N.

```{r}
#| eval: false
acc <- read_csv("data/rawdata/thai_road_accident_2019_2022.csv") %>%
  mutate(Month_num = month(incident_datetime)) %>%
  mutate(Month_fac = month(incident_datetime,
                       label = TRUE,
                       abbr = TRUE)) %>%
  mutate(dayofweek = weekdays(incident_datetime))%>%
  filter(!is.na(longitude) & !is.na(latitude)) %>%  # Remove rows with missing coordinates
  st_as_sf(coords = c("longitude", "latitude"),
                       crs=4326) %>%
  st_transform(crs = 32647)
```

Save to a rds file

```{r}
#| eval: false
write_rds(acc, "data//acc.rds")
```

Read the processed rds file in again

```{r}
#| eval: false
acc <- read_rds("data/acc.rds")
```

We only need metropolitan region (BMR), so filter them out

```{r}
#| eval: false
bmr_provinces <- c("Bangkok", "Nakhon Pathom", "Pathum Thani", "Nonthaburi", "Samut Prakan", "Samut Sakhon")

bmr_acc_data <- acc %>%
  filter(province_en %in% bmr_provinces)
```

Write filtered data in a file

```{r}
#| eval: false
write_rds(bmr_acc_data,"data/bmr_acc_data.rds")
```

Read in the filtered file

```{r}
bmr_acc_data <- read_rds("data/bmr_acc_data.rds")
```

###1.2 Thai Road data

```{r}
# Read the shapefile using relative path
roads <- st_read(dsn = "data/rawdata/hotosm_tha_roads_lines_shp", layer = "hotosm_tha_roads_lines_shp")
```

###1.3 Admin Boundary Data Read in admin boundary data1

```{r}
#| eval: false
admin_boundaries <- st_read(dsn = "data/rawdata/tha_adm_rtsd_itos_20210121_shp", layer = "tha_admbnda_adm1_rtsd_20220121")
```

Filter out BMR boundary from the data set

```{r}
#| eval: false
bmr_provinces <- c("Bangkok", "Nakhon Pathom", "Pathum Thani", "Nonthaburi", "Samut Prakan", "Samut Sakhon")

# Filter out Bangkok Metropolitan Region (BMR)'s boundary
bmr_boundary <- admin_boundaries %>%
  filter(ADM1_EN %in% bmr_provinces)

head(bmr_boundary)
```

Write it in a file and read it back in

```{r}
#| eval: false
write_rds(bmr_boundary, "data/bmr_boundary.rds")
```

```{r}
bmr_boundary <- read_rds("data/bmr_boundary.rds")
```

Transform the data to WGS84 crs 4326

```{r}
roads <- st_transform(roads, crs = 4326)
```

\#`{r} #这里先不需要，先做全部的KDE #Filter out road in BMR region #`{r}
\# 计算道路和BMR边界的交集 #bmr_roads \<- st_intersection(roads,
bmr_boundary) #\`\`\`

#Save intersection of bmr1 and roadto a file
\#`{r} #write_rds(bmr_roads, "data/bmr_roads.rds") #`

\#`{r} # 查看 BMR 边界数据的前几行 #head(bmr_boundary) #`

####02 Analysis of the distribution of Car Accidents among Thailand
###1st Order Spatial Point Pattern Analysis

```{r}
pacman::p_load(sf, raster, spatstat, tmap, tidyverse)
```

2.1 Prepare Data
Check if datasets are in the same projection system

```{r}
# Load necessary libraries
library(sf)

# Load the RDS datasets from the correct relative paths
bmr_acc_data <- readRDS("data/bmr_acc_data.rds")
bmr_boundary <- readRDS("data/bmr_boundary.rds")
bmr_roads <- readRDS("data/bmr_roads.rds")

# Check the CRS of each dataset

cat("BMR Accident Data CRS:\n")
print(st_crs(bmr_acc_data))

cat("BMR Boundary CRS:\n")
print(st_crs(bmr_boundary))

cat("BMR Roads CRS:\n")
print(st_crs(bmr_roads))

```

Transform the accident data and BMR accident data to EPSG:32647

```{r}
# Transform BMR accident data and BMR boundary to EPSG:32647 (UTM Zone 47N)
bmr_acc_data <- st_transform(bmr_acc_data, crs = 32647)
bmr_boundary <- st_transform(bmr_boundary, crs = 32647)

# Check CRS to ensure correct projection
cat("BMR Accident Data CRS:\n")
print(st_crs(bmr_acc_data))

cat("BMR Boundary CRS:\n")
print(st_crs(bmr_boundary))
```

Perform KDE on BMR Accident Data

```{r}
# Load necessary libraries
library(sf)
library(tmap)

# Base R plot (Simple)
plot(st_geometry(bmr_boundary), col = "lightgrey", border = "black", main = "BMR Accident Locations (Base R)")

# Add the accident points on top of the boundary map with smaller dots
plot(st_geometry(bmr_acc_data), col = "black", pch = 19, cex = 0.1, add = TRUE)  # Adjust point size using cex

# tmap version (More flexible visualization)
tm_shape(bmr_boundary) +
  tm_borders(col = "black", lwd = 1) +  # Plot boundary with black borders
  tm_shape(bmr_acc_data) +
  tm_dots(col = "black", size = 0.01) +  # Adjust dot size using size = 0.05
  tm_layout(title = "BMR Accident Locations (tmap)")

```

2.2  Comvert data to ppp
Convert sf to sp
```{r}
# Load necessary libraries
library(sf)
library(sp)

# Convert BMR accident data from sf to sp class
bmr_acc_data_sp <- as_Spatial(bmr_acc_data)

# Convert BMR boundary from sf to sp class
bmr_boundary_sp <- as_Spatial(bmr_boundary)

# Check the class of the converted objects to ensure they are now Spatial* objects
class(bmr_acc_data_sp)
class(bmr_boundary_sp)
```

```{r}
# Extract the coordinates (longitude and latitude) from SpatialPoints
acc_coords <- coordinates(bmr_acc_data_sp)  # Using the correct variable 'bmr_acc_sp'

# Extract the bounding box from the BMR boundary
bbox_values <- bbox(bmr_boundary_sp)  # Using the correct variable 'bmr_boundary_sp_generic'

# Manually create the observation window (owin) using the bounding box
bmr_window <- owin(xrange = c(bbox_values[1, 1], bbox_values[1, 2]), 
                   yrange = c(bbox_values[2, 1], bbox_values[2, 2]))

# Convert the coordinates to a ppp object for spatstat
bmr_acc_ppp <- ppp(x = acc_coords[, 1], y = acc_coords[, 2], window = bmr_window)

# Display the ppp object
bmr_acc_ppp

# Plot the ppp object with smaller points
plot(bmr_acc_ppp, main = "BMR Accident Locations", cex = 0.5)  # Adjust 'cex' for smaller points

```

2.3 **Handling Duplicate Points**

```{r}
any(duplicated(bmr_acc_ppp))
```

Show points with Duplicate

```{r}
multiplicity(bmr_acc_ppp)
```

Check how many points have duplicates

```{r}
sum(multiplicity(bmr_acc_ppp) > 1)
```

```{r}
# Check if there are any duplicate points
any(duplicated(bmr_acc_ppp))

# Count how many points have duplicates
sum(duplicated(bmr_acc_ppp))

# Check the total number of points in the dataset
total_points <- npoints(bmr_acc_ppp)

# Calculate the percentage of duplicates
duplicate_percentage <- (sum(duplicated(bmr_acc_ppp)) / total_points) * 100

# Print the results
print(paste("Total points:", total_points))
print(paste("Number of duplicates:", sum(duplicated(bmr_acc_ppp))))
print(paste("Percentage of duplicates:", duplicate_percentage))

```

```{r}
# Extract the coordinates from the ppp object
acc_coords <- coords(bmr_acc_ppp)

# Convert the coordinates to a data frame for easier handling
acc_coords_df <- as.data.frame(acc_coords)

# Find the unique rows (unique locations)
unique_locations <- unique(acc_coords_df)

# Count how many unique locations there are
num_unique_locations <- nrow(unique_locations)

# Print the result
print(paste("Total unique locations:", num_unique_locations))

```

We rjitter to deal with duplicates

```{r}
# Apply jittering to the BMR accident point pattern (ppp object)
# nsim = 1 means one simulation, retry = TRUE retries jittering if a point overlaps
# drop = TRUE ensures any points that fall outside the window are dropped
bmr_acc_ppp_jit <- rjitter(bmr_acc_ppp, retry = TRUE, nsim = 1, drop = TRUE)

# Plot the jittered points with smaller size
plot(bmr_acc_ppp_jit, main = "Jittered BMR Accident Locations", cex = 0.5)  # Adjust 'cex' for smaller points
```

Check if there anymore duplicates--no

```{r}
any(duplicated(bmr_acc_ppp_jit))
```

2.4 Combine point events object and owin object
```{r}
# Combine jittered BMR accident data with the BMR boundary (owin object)
bmr_acc_ppp_final <- bmr_acc_ppp_jit[bmr_window]

# Display summary information of the combined ppp object
summary(bmr_acc_ppp_final)

# Plot the combined ppp object with smaller points
plot(bmr_acc_ppp_final, main = "Jittered BMR Accident Locations Within BMR Boundary", cex = 0.5)
```
2.5 Kernel Density Estimation -- KDE Analysis
2.5.1  Computing kernel density estimation using automatic bandwidth selection method
```{r}
# Load spatstat if needed
library(spatstat)

# Compute kernel density estimation with automatic bandwidth selection (bw.diggle)
kde_bmr_acc <- density(bmr_acc_ppp_final,  # Use the final ppp object after jittering and combining with owin
                       sigma = bw.diggle(bmr_acc_ppp_final),  # Automatic bandwidth selection
                       edge = TRUE,  # Correct for edge effects
                       kernel = "gaussian")  # Use gaussian kernel (default)

# Plot the kernel density estimation
plot(kde_bmr_acc, main = "Kernel Density Estimation of BMR Accident Data (bw.diggle)")

```

The bandwidth is too small to observe the pattern, so we check the parameter and tune it

Adjust sigma without rescalling and Compute the KDE
```{r} 
# Load spatstat if needed
library(spatstat)

# Define a custom value for sigma (in meters, since data is in UTM projection)
sigma_value <- 12000  # Adjust this value based on your smoothing preference

# Compute kernel density estimation with manual sigma
kde_bmr_acc <- density(bmr_acc_ppp_final,  # Use the final ppp object after jittering and combining with owin
                       sigma = sigma_value,  # Use custom sigma value (in meters)
                       edge = TRUE,  # Correct for edge effects
                       kernel = "gaussian")  # Use gaussian kernel (default)

# Plot the kernel density estimation
plot(kde_bmr_acc, main = paste("Kernel Density Estimation of BMR Accident Data (sigma =", sigma_value, "meters)"))

# Optionally add the boundary if needed (to show BMR region)
plot(bmr_boundary_sp, add = TRUE, border = "white", lwd = 2)  # Adjust line width and color as needed

```
This image shows a Kernel Density Estimation (KDE) of road accidents in the Metropolitan Region of Thailand with a sigma of 4000 meters. The yellow areas, especially in the Bangkok, represent regions with the highest number of accidents, indicating high accident frequency. We will zoom in to Bangkok to further study the pattern of car accidents in more detail.

####03 Network Spatial Point Patterns Analysis of Bangkok --NKDE
3.1 Data
3.1.1 Filter out Accident, Road and Boundary Data of Bankok

```{r}
pacman::p_load(sf, spNetwork, tmap, tidyverse)
```

Filter accident and boundary data for Bangkok
```{r}
bangkok_accidents <- bmr_acc_data %>%
  filter(province_en == "Bangkok")

bangkok_boundary <- bmr_boundary %>% 
  filter(ADM1_EN == "Bangkok")
```

Check and transfer coordinates
```{r}
st_crs(bmr_roads)
st_crs(bmr_boundary)
st_crs(bmr_acc_data)

```
Transform to EPSG:32647
```{r}
bmr_roads <- st_transform(bmr_roads, crs = 32647)
bmr_boundary <- st_transform(bmr_boundary, crs = 32647)
bmr_acc_data <- st_transform(bmr_acc_data, crs = 32647)
```



Intersection Bankok road with boundary
```{r}
#| eval: false
# Ensure bmr_roads and bangkok_boundary are sf objects
bmr_roads_sf <- st_as_sf(bmr_roads)
bkk_boundary_sf <- st_as_sf(bangkok_boundary)

# Transform the boundary data to match the CRS of the road data (EPSG:32647)
bkk_boundary_sf <- st_transform(bkk_boundary_sf, st_crs(bmr_roads_sf))

# Perform intersection: roads within Bangkok boundary
bkk_roads <- st_intersection(bmr_roads_sf, bkk_boundary_sf)

```

Save as rds
```{r}
saveRDS(bkk_roads, "bkk_roads.rds")
saveRDS(bkk_boundary_sf, "bkk_boundary.rds")
saveRDS(bangkok_accidents, "bkk_acc.rds")
```


Read Bangkok Data in
```{r}
bkk_roads <- readRDS("data/bkk_roads.rds")
bkk_boundary_sf <- readRDS("data/bkk_boundary.rds")
bkk_accidents <- readRDS("data/bkk_acc.rds")
```

Transform to coordinate system to 32647
```{r}
bkk_roads <- st_transform(bkk_roads, crs = 32647)
bkk_boundary_sf <- st_transform(bkk_boundary_sf, crs = 32647)
bkk_accidents <- st_transform(bkk_accidents, crs = 32647)
```
```{r}
print(st_crs(bkk_roads))
print(st_crs(bkk_boundary_sf))
print(st_crs(bkk_accidents))
print(st_crs(bkk_major_roads))
```

```{r}
# Plot road network first (as lines)
plot(st_geometry(bkk_roads), col = "blue", lwd = 0.1, main = "Bangkok Roads with Accidents")

# Add points (accidents) on top of the road network in red
plot(st_geometry(bkk_accidents), add = TRUE, col = "red", pch = 19, cex=0.1)
```

```{r}
# Load the dplyr package for filtering
library(dplyr)

# List of road types to filter out
major_roads <- c("secondary", "secondary_link", "primary", "primary_link", 
                 "trunk", "trunk_link", "motorway", "motorway_link")

# Filter the bkk_roads dataset to exclude these major road types
bkk_major_roads <- bkk_roads %>%
  filter(highway %in% major_roads)

# View the filtered dataset
head(bkk_major_roads)
```
Filter out NA from road
```{r}
bkk_major_roads <- bkk_major_roads %>% 
  filter(!is.na(name_en))

print(bkk_major_roads)
```
Check coordinates
```{r}
print(st_crs(bkk_roads))
print(st_crs(bkk_boundary_sf))
print(st_crs(bkk_accidents))
print(st_crs(bkk_major_roads))
```
Transform to coordinate system to 32647
```{r}
bkk_roads <- st_transform(bkk_roads, crs = 32647)
bkk_boundary_sf <- st_transform(bkk_boundary_sf, crs = 32647)
bkk_accidents <- st_transform(bkk_accidents, crs = 32647)
```
```{r}
print(st_crs(bkk_roads))
print(st_crs(bkk_boundary_sf))
print(st_crs(bkk_accidents))
print(st_crs(bkk_major_roads))
```
```{r}
bkk_major_roads <- bkk_major_roads %>%
  filter(st_geometry_type(bkk_major_roads) %in% c("LINESTRING", "MULTILINESTRING"))
```

```{r}
bkk_major_roads <- st_cast(bkk_major_roads, "LINESTRING", group_or_split = TRUE)

```

```{r}
st_geometry_type(bkk_major_roads)
```


3.2 Preparing the lixels objects


```{r}
bkk_lixels <- lixelize_lines(bkk_major_roads, 
                         10000, 
                         mindist = 5000)
```

Generate sample points
```{r}
bkk_sample <- lines_center(bkk_lixels)
```


#报错修改
```{r}
library(sf)
invalid_geometries <- st_is_valid(bkk_major_roads_cast)
invalid_geometries[!invalid_geometries]  # Identify invalid geometries
```
```{r}
library(sf)

# Step 1: Validate geometries
invalid_geometries <- st_is_valid(bkk_major_roads)
invalid_geometries[!invalid_geometries]  # Identify invalid geometries

# Step 2: Fix invalid geometries
bkk_major_roads_cast <- st_make_valid(bkk_major_roads)

# Step 3: Ensure geometries are of type LINESTRING
bkk_major_roads_cast <- st_cast(bkk_major_roads, "LINESTRING")

# Step 4: Simplify geometries if necessary
bkk_major_roads_cast <- st_simplify(bkk_major_roads, dTolerance = 0.001)

# Step 5: Recheck the validity of geometries
invalid_geometries <- st_is_valid(bkk_major_roads)
invalid_geometries[!invalid_geometries]  # Check if any invalid geometries remain

```
```{r}
invalid_geometries <- st_is_valid(bkk_major_roads)
sum(!invalid_geometries)  # 计算无效几何图形的数量

```

```{r}
# 修复无效几何图形
bkk_major_roads <- st_make_valid(bkk_major_roads)

# 再次检查是否所有几何图形都已经修复
invalid_geometries <- st_is_valid(bkk_major_roads)
sum(!invalid_geometries)  # 应该输出 0

```

```{r}
bkk_nkde <- nkde(
  lines = bkk_major_roads,                      # 替换为 Bangkok 的 lixels
  events = bkk_accidents,                     # 替换为 Bangkok 的事故数据
  w = rep(1, nrow(bkk_accidents)),            # 权重
  samples = bkk_sample,                   # 使用 samples_bangkok
  kernel_name = "quartic",                     # 四次核
  bw = 500,                                    # 带宽为500米
  div = "bw",                                  # 带宽标准化
  method = "simple",                           # 简单方法
  grid_shape = c(200, 200),                    # 网格形状
  verbose = TRUE                               # 打印详细信息
)
```
```{r}
class(bkk_major_roads)
```
```{r}
# 提取 bkk_major_roads 中的几何信息，只保留 sf 几何对象
bkk_major_roads_geometry <- st_geometry(bkk_major_roads)

# 查看新对象的类
class(bkk_major_roads_geometry)

```
```{r}
# 将几何对象转换为 LINESTRING
bkk_major_roads_linestring <- st_cast(bkk_major_roads_geometry, "LINESTRING")

```
```{r}
# 检查几何类型并过滤掉 POINT 几何，只保留 LINESTRING 和 MULTILINESTRING
bkk_major_roads_filtered <- bkk_major_roads_geometry[st_geometry_type(bkk_major_roads_geometry) %in% c("LINESTRING", "MULTILINESTRING")]

# 确认过滤后的几何类型
print(st_geometry_type(bkk_major_roads_filtered))

# 将 MULTILINESTRING 转换为 LINESTRING
bkk_major_roads_linestring <- st_cast(bkk_major_roads_filtered, "LINESTRING")

# 确认转换后的几何类型
print(st_geometry_type(bkk_major_roads_linestring))

```
```{r}
# 生成 lixels 对象，指定每个单元的长度和最小距离
bkk_lixels <- lixelize_lines(bkk_major_roads_linestring, 
                             length = 10000,   # 设置线段长度为1000米
                             mindist = 5000)   # 设置最小间距为500米

# 生成 lixels 的中心点作为采样点
bkk_sample_points <- lines_center(bkk_lixels)

```


